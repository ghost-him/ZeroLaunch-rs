<template>
    <div class="shortcut-settings" style="height: 100%; overflow-y: auto;">
        <div class="shortcut-header">
            <h2 class="shortcut-title">{{ t('shortcut.title') }}</h2>
            <div class="shortcut-actions">
                <el-button type="primary" @click="edit_shortcut_config" :disabled="is_saving">
                    <el-icon>
                        <Edit v-if="!is_editing" />
                        <Close v-else />
                    </el-icon>
                    {{ is_editing ? t('shortcut.cancel_edit') : t('shortcut.start_setting') }}
                </el-button>
                <el-button type="success" @click="save_shortcut_config" :loading="is_saving" :disabled="!is_editing">
                    <el-icon>
                        <Check />
                    </el-icon>
                    {{ t('shortcut.save_settings') }}
                </el-button>
                <el-button type="warning" @click="resetAllShortcuts" :disabled="!is_editing">
                    <el-icon>
                        <RefreshLeft />
                    </el-icon>
                    {{ t('shortcut.reset_all') }}
                </el-button>
            </div>
        </div>

        <el-divider content-position="left">{{ t('shortcut.system_shortcuts') }}</el-divider>
        <div class="shortcut-settings-container">
            <el-form label-position="top" class="shortcut-form">
                <el-form-item v-for="item in shortcutItems" :key="item.key" class="shortcut-form-item">
                    <div class="shortcut-item-header">
                        <div class="shortcut-label">
                            <el-icon>
                                <component :is="item.icon" />
                            </el-icon>
                            <span>{{ item.label }}</span>
                        </div>
                        <el-tooltip :content="item.tooltip" placement="top" effect="light">
                            <el-icon class="info-icon">
                                <InfoFilled />
                            </el-icon>
                        </el-tooltip>
                    </div>

                    <div class="shortcut-item-content">
                        <ShortcutInput v-model="dirty_shortcut_config[item.key]" :disabled="!is_editing"
                            :placeholder="item.placeholder">
                        </ShortcutInput>

                        <el-button class="reset-button" :disabled="!is_editing" @click="resetShortcut(item.key)">
                            <el-icon>
                                <RefreshRight />
                            </el-icon>
                            {{ t('shortcut.reset') }}
                        </el-button>
                    </div>
                </el-form-item>
            </el-form>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { default_shortcut_config, ShortcutConfig } from '../api/remote_config_types';
import ShortcutInput from '../utils/ShortcutInput.vue';
import { onUnmounted, ref, markRaw } from 'vue';
import { onMounted } from 'vue';
import { invoke } from '@tauri-apps/api/core';
import { useRemoteConfigStore } from '../stores/remote_config';
import { ElMessage, ElMessageBox } from 'element-plus';
import { useI18n } from 'vue-i18n';
import {
    Search, ArrowLeft, ArrowRight, ArrowUp, ArrowDown,
    InfoFilled, Edit, Close, Check, RefreshLeft,
    RefreshRight
} from '@element-plus/icons-vue';
import type { Component } from 'vue'
const { t } = useI18n();
const configStore = useRemoteConfigStore();
const is_editing = ref<boolean>(false);
const is_saving = ref<boolean>(false);
const d_shortcut_config: ShortcutConfig = default_shortcut_config();
const dirty_shortcut_config = ref<ShortcutConfig>({ ...configStore.config.shortcut_config });

// 定义快捷键标签和描述
type ShortcutKey = keyof ShortcutConfig;
const shortcutItems = ref<Array<{
    key: keyof ShortcutConfig;
    icon: Component;
    label: string;
    tooltip: string;
    placeholder: string;
}>>([
    {
        key: 'open_search_bar',
        icon: markRaw(Search),
        label: t('shortcut.open_search_bar'),
        tooltip: t('shortcut.open_search_bar_tooltip'),
        placeholder: t('shortcut.open_search_bar_placeholder')
    },
    {
        key: 'arrow_left',
        icon: markRaw(ArrowLeft),
        label: t('shortcut.arrow_left'),
        tooltip: t('shortcut.arrow_left_tooltip'),
        placeholder: t('shortcut.arrow_left_placeholder')
    },
    {
        key: 'arrow_right',
        icon: markRaw(ArrowRight),
        label: t('shortcut.arrow_right'),
        tooltip: t('shortcut.arrow_right_tooltip'),
        placeholder: t('shortcut.arrow_right_placeholder')
    },
    {
        key: 'arrow_up',
        icon: markRaw(ArrowUp),
        label: t('shortcut.arrow_up'),
        tooltip: t('shortcut.arrow_up_tooltip'),
        placeholder: t('shortcut.arrow_up_placeholder')
    },
    {
        key: 'arrow_down',
        icon: markRaw(ArrowDown),
        label: t('shortcut.arrow_down'),
        tooltip: t('shortcut.arrow_down_tooltip'),
        placeholder: t('shortcut.arrow_down_placeholder')
    }
]);

const edit_shortcut_config = async () => {
    if (is_editing.value) {
        // 取消编辑，恢复原始配置
        dirty_shortcut_config.value = { ...configStore.config.shortcut_config };
        is_editing.value = false;
        try {
            await invoke('command_register_all_shortcut');
            ElMessage.info(t('shortcut.edit_cancelled'));
        } catch (error) {
            handleError(t('shortcut.restore_failed') + error);
        }
    } else {
        try {
            await invoke('command_unregister_all_shortcut');
            is_editing.value = true;
            ElMessage.success({
                message: t('shortcut.edit_mode_entered'),
                duration: 2000
            });
        } catch (error) {
            handleError(t('shortcut.unbind_failed') + error);
        }
    }
}

const save_shortcut_config = async () => {
    is_saving.value = true;
    try {
        await configStore.updateConfig({ shortcut_config: dirty_shortcut_config.value });
        await configStore.syncConfig();
        is_editing.value = false;
        ElMessage.success({
            message: t('shortcut.settings_saved'),
            type: 'success',
            duration: 2000
        });
    } catch (error) {
        handleError(t('shortcut.save_failed') + error);
        try {
            await invoke('command_register_all_shortcut');
        } catch (e) {
            handleError(t('shortcut.restore_default_failed') + e);
        }
    } finally {
        is_saving.value = false;
    }
}

const resetShortcut = (key: ShortcutKey) => {
    dirty_shortcut_config.value[key] = d_shortcut_config[key];
    ElMessage.info(t('shortcut.reset_to_default'));
}

const resetAllShortcuts = async () => {
    try {
        await ElMessageBox.confirm(
            t('shortcut.reset_all_confirm'),
            t('shortcut.reset_confirm_title'),
            {
                confirmButtonText: t('shortcut.confirm_reset'),
                cancelButtonText: t('shortcut.cancel'),
                type: 'warning',
            }
        );
        dirty_shortcut_config.value = { ...d_shortcut_config };
        ElMessage.success(t('shortcut.all_reset_success'));
    } catch {
        // 用户取消操作
    }
}

const handleError = (error: string) => {
    ElMessage({
        showClose: true,
        message: error,
        type: 'error',
        duration: 5000
    });
}

onMounted(async () => {
    // 初始化逻辑
})

onUnmounted(async () => {
    if (is_editing.value) {
        await invoke('command_register_all_shortcut');
        is_editing.value = false;
    }
})
</script>

<style scoped>
.shortcut-settings {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

.shortcut-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.shortcut-title {
    font-size: 22px;
    color: #303133;
    margin: 0;
}

.shortcut-actions {
    display: flex;
    gap: 12px;
}

.shortcut-settings-container {
    margin-top: 20px;
}

.shortcut-form {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 20px;
}

.shortcut-form-item {
    background-color: var(--el-bg-color);
    padding: 16px;
    border-radius: 8px;
    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.05);
    transition: all 0.3s;
    margin: 0;
}

.shortcut-form-item:hover {
    box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.1);
}

.shortcut-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
}

.shortcut-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 500;
    color: var(--el-text-color-primary);
}

.info-icon {
    color: var(--el-color-info);
    cursor: pointer;
    font-size: 16px;
}

.shortcut-item-content {
    display: flex;
    align-items: center;
    gap: 12px;
}

.reset-button {
    display: flex;
    align-items: center;
    gap: 4px;
    color: var(--el-color-primary);
    transition: all 0.2s;
}

.reset-button:hover:not(:disabled) {
    color: var(--el-color-primary-light-3);
    background-color: var(--el-color-primary-light-9);
}

.reset-button:disabled {
    color: var(--el-text-color-disabled);
    cursor: not-allowed;
}

:deep(.el-form-item__content) {
    display: flex;
    flex-direction: column;
    align-items: stretch;
}

:deep(.el-divider__text) {
    font-size: 16px;
    font-weight: 500;
    color: var(--el-text-color-secondary);
}
</style>